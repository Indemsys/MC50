// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// 2023-10-13
// 15:26:33
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#include   "MC50.h"


T_Hall_3PH_cbl  h3;
/*-----------------------------------------------------------------------------------------------------


-----------------------------------------------------------------------------------------------------*/
void Hall_3PH_reinit(void)
{
  h3.turn_capt = 0;

  h3.U_edg_n = 0;
  h3.V_edg_n = 0;
  h3.W_edg_n = 0;

  for (uint32_t i=0; i < 8; i++)
  {
    h3.U_capt_prev[i]= -1;
    h3.V_capt_prev[i]= -1;
    h3.W_capt_prev[i]= -1;

    h3.U_capt[i] = 0;
    h3.V_capt[i] = 0;
    h3.W_capt[i] = 0;
  }
}

/*-----------------------------------------------------------------------------------------------------


  \param void
-----------------------------------------------------------------------------------------------------*/
void Hall_3PH_capture_bitmask(void)
{
  h3.bitmask = R_IOPORT5->PCNTR2 & 0x7;

  if ((h3.bitmask == 0) || (h3.bitmask == 0x7)) App_set_error_flags(APP_ERR_HALL_STATE_FAULT);

  // Устаналиваем переменные применяемы при отладке через FreeMaster
  h3.U_bit =(h3.bitmask >> 0) & 1;
  h3.V_bit =(h3.bitmask >> 1) & 1;
  h3.W_bit =(h3.bitmask >> 2) & 1;
}


/*-----------------------------------------------------------------------------------------------------
  Измерение скорости вращения ротора BLDC мотора и направления вращения с 3-фазной сборки датчиков Холла
  Измерение производится с помощью датчиков Холла и логики захвата таймеров GPT_11 и GPT_12
  Логика захвата реагирует на подъем и на спад, таким образом за полный оборот 8-полюсного ротора приходит 8 фронтов сигнала с каждого датчика

  Рабочие скорости в диапазоне от 0.5 об/сек (30 RPM) до 8 об/сек (480 RPM)
-----------------------------------------------------------------------------------------------------*/
void Hall_3PH_measure_speed_and_direction(void)
{
  uint32_t  st;
  int32_t  val;
  uint8_t   h;

  st = R_GPTB3->GTST;  // Читаем флаги состояния capture таймера  GPT3211


  // ......................................................
  // Обработка сигнала ENCU
  // ......................................................
  if (st & BIT(0))     // Проверяем флаг TCFA. Input Capture/Compare Match Flag A
  {
    // Здесь если событие захвата произошло

    R_GPTB3->GTST = 0;      // Очищаем флаг захвата и остальные флаги.
                            // За другие флаги захвата не беспокоимся, поскольку они при штатной работе не могут быть взведены в этот момент.

    val = R_GPTB3->GTCCRA;  // Читаем регистр с захваченным состоянием счетчика

    // Здесь рассчитываем разницу по отношению к предыдущему захваченному значению на том же угле поворота ротора, т.е. для полюса с номером в переменной hall_u_cnt
    if (h3.U_capt_prev[h3.U_edg_n] > 0)
    {
      if (val >h3. U_capt_prev[h3.U_edg_n])
      {
        h3.U_capt[h3.U_edg_n] = val - h3.U_capt_prev[h3.U_edg_n];
      }
      else
      {
        // Корректируем если было произошло переполнение счетчика между захватами
        h3.U_capt[h3.U_edg_n] =  0x7FFFFFFF -(h3.U_capt_prev[h3.U_edg_n] - val -1);
      }
      h3.turn_capt = h3.U_capt[h3.U_edg_n];     // Записываем длительность полного оборота ротора в глобальную переменную для дальнейшего использования остальными задачами
    }
    h3.U_capt_prev[h3.U_edg_n] = val;           // Сохраняем текущее захваченное значение в переменную предыдущего значения
    h3.U_edg_n++;                               // Ведем счет полюсов. Для каждого полюса сохраняется своя измеренная величина
    if (h3.U_edg_n >= 8) h3.U_edg_n = 0;

    // Определяем направление вращения
    h = R_IOPORT5->PCNTR2 & 0x7;  // Читаем сигналы датчиков Холла здесь снова, несмотря на то что они уже были прочитаны в обработчике прерывания
                                  // Это нужно поскольку capture логика может сработать уже после того как в ISR были прочитаны состояния датчиков
    if ((h == 0b100) || (h == 0b011))      h3.rot_dir = 1; // Направление вращения определяем по паттернам сигнало с датчиков сразу после текущего фронта
    else if ((h == 0b010) || (h == 0b101)) h3.rot_dir = -1;

    R_GPTB5->GTCLR_b.CCLR13 = 1;  // Сброс счетчика отслеживающего остановку вращения
    R_GPTB5->GTST           = 0;  // Сброс флагов счетчика отслеживающего остановку вращения
  }

  // ......................................................
  // Обработка сигнала ENCV
  // ......................................................
  if (st & BIT(1))
  {
    // Input capture/compare match of GTCCRB occurred
    R_GPTB3->GTST = 0;
    val = R_GPTB3->GTCCRB;
    if (h3.V_capt_prev[h3.V_edg_n] > 0)
    {
      if (val > h3.V_capt_prev[h3.V_edg_n])
      {
        h3.V_capt[h3.V_edg_n] = val - h3.V_capt_prev[h3.V_edg_n];
      }
      else
      {
        h3.V_capt[h3.V_edg_n] =  0x7FFFFFFF -(h3.V_capt_prev[h3.V_edg_n] - val -1);
      }
      h3.turn_capt = h3.V_capt[h3.V_edg_n];
    }
    h3.V_capt_prev[h3.V_edg_n] = val;
    h3.V_edg_n++;
    if (h3.V_edg_n >= 8) h3.V_edg_n = 0;

    h = R_IOPORT5->PCNTR2 & 0x7;  // Читаем сигналы датчиков Холла здесь чтобы они были прочитаны не раньше чем стработает capture логика
    if ((h == 0b110) || (h == 0b001))      h3.rot_dir = 1;
    else if ((h == 0b011) || (h == 0b100)) h3.rot_dir = -1;

    R_GPTB5->GTCLR_b.CCLR13 = 1;  // Сброс счетчика отслеживающего остановку вращения
    R_GPTB5->GTST           = 0;
  }


  st = R_GPTB4->GTST;

  // ......................................................
  // Обработка сигнала ENCW
  // ......................................................
  if (st & BIT(0))
  {
    // Input capture/compare match of GTCCRA occurred
    R_GPTB4->GTST = 0;
    val = R_GPTB4->GTCCRA;
    if (h3.W_capt_prev[h3.W_edg_n] > 0)
    {
      if (val > h3.W_capt_prev[h3.W_edg_n])
      {
        h3.W_capt[h3.W_edg_n] = val - h3.W_capt_prev[h3.W_edg_n];
      }
      else
      {
        h3.W_capt[h3.W_edg_n] =  0x7FFFFFFF -(h3.W_capt_prev[h3.W_edg_n] - val -1);
      }
      h3.turn_capt = h3.W_capt[h3.W_edg_n];
    }
    h3.W_capt_prev[h3.W_edg_n] = val;
    h3.W_edg_n++;
    if (h3.W_edg_n >= 8) h3.W_edg_n = 0;

    h = R_IOPORT5->PCNTR2 & 0x7;  // Читаем сигналы датчиков Холла здесь чтобы они были прочитаны не раньше чем стработает capture логика
    if ((h == 0b101) || (h == 0b010))      h3.rot_dir = 1;
    else if ((h == 0b110) || (h == 0b001)) h3.rot_dir = -1;

    R_GPTB5->GTCLR_b.CCLR13 = 1;  // Сброс счетчика отслеживающего остановку вращения
    R_GPTB5->GTST           = 0;
  }

  // ......................................................
  // Блок линейно понижающий скорость в случает отсутствия сигналов с датчиков Холла
  // ......................................................
  if (h3.turn_capt != 0)
  {
    if (R_GPTB5->GTST & BIT(6))  // Проверяем флаг TCFPO. Overflow Flag
    {
      // В случае переполения тамера сразу отмечаем скорость как нулевую.
      // Поскольку переполение таймера происходит с периодом в две секунды, то такую низкую скрость принимаем как нулевую
      Hall_3PH_reinit();
      R_GPTB5->GTST = 0;
    }
    else
    {
      // За один оборот мотора мы имеем 8 полюсов * 3 датчика = 24 события сброса таймера R_GPTB5
      // И если таймер R_GPTB5 смог набрать 2/3 (16/24) длительности одного оборота и не был сброшен значит скорость упала
      // и можно начинать снижать оценку текущей скорости
      uint32_t no_edge_period = R_GPTB5->GTCNT * 16;
      if (no_edge_period > h3.turn_capt)
      {
        h3.turn_capt = no_edge_period;
      }
    }
  }
}





