// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// 2023-03-01
// 12:52:05
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#include   "MC50.h"


/*-----------------------------------------------------------------------------------------------------
  Инициализация таймера GPT0 (согласно обозначению в даташите) или R_GPTA0 (согласно обозначению в хидере)
  Используеся для управления коммутацией BLDC мотора с использованием функции Output Phase Switching Control (OPS)

  Настройка ШИМ на треугольный режим с перегрузкой на впадине

  Таймер тактируется частотой PCLKD = 120 МГц

  \param freq - частота ШИМ

  \return uint32_t
-----------------------------------------------------------------------------------------------------*/
uint32_t GPT0_PWM_w_OPS_init(uint32_t freq)
{
  uint32_t mod = PCLKD_FREQ / (freq*2);

  if (mod < 0x21) return RES_ERROR; // Не даем ошибочно выбрать слишком высокую частоту ШИМ

  R_MSTP->MSTPCRD_b.MSTPD5 = 0;     // Разрешаем работу модулей GPT ch7-ch0

  R_GPTA0->GTWP_b.PRKEY  = 0xA5;    // Разрешаем запись в бит WP этого регистра
  R_GPTA0->GTWP_b.WP     = 0;       // 0: Enable writes to the register Разрешаем запись в остальные регистры таймера

  R_GPTA0->GTCR_b.CST    = 0;       // Останавливаем счет

  R_GPTA0->GTCNT         = 0;       // Обнуляем таймер
  R_GPTA0->GTPR          = mod - 1; // Устанавливаем регистр задающий верхний предел таймера
  R_GPTA0->GTIOR         = 0;       // Очищаем настройки выходов. Все запрещены

  // Отклчючаем все флаги счета внешних импульсов
  R_GPTA0->GTUPSR        = 0;       // General PWM Timer Up Count Source Select Register
  R_GPTA0->GTDNSR        = 0;       // General PWM Timer Down Count Source Select Register

  R_GPTA0->GTUDDTYC_b.UDF= 1;       // Сразу вступает в силу установка инкремента счетчика
  R_GPTA0->GTUDDTYC_b.UD = 1;       // Счетчик инкрементируется


  R_GPTA0->GTCR_b.TPCS   = 0;       // Timer Prescaler Select. 0 0 0: PCLKD/1
  R_GPTA0->GTCR_b.MD     = 4;       // 100: Triangle-wave PWM mode 1 (32-bit transfer at trough) (single buffer or double buffer possible)

  R_GPTA0->GTBER_b.BD    = 0;       // Снимаем запрещение буфферизированной записи в регистры GTCCR, GTPR, GTADTR, GTDV

  R_GPTA0->GTBER_b.CCRA  = 1;       // GTCCRA Buffer Operation. 01: Single buffer operation (GTCCRA <- GTCCRC).
  R_GPTA0->GTCCRA        = mod - MIN_PWM_COMPARE_VAL; // Загружаем начальное значение в компаратор A. Устанавливаем минимальную длительность начального импульса
  R_GPTA0->GTCCRC        = mod - MIN_PWM_COMPARE_VAL; // Загружаем буфферизированное начальное значение в компаратор A
  R_GPTA0->GTIOR_b.GTIOA = 0x03;    // Set initial output low, Retain output at cycle end, Toggle output at GTCCRA/GTCCRB compare match
                                    // Здесь сигнал в начале имеет низкий уровень , во время нарастания счетчика на событии compare match он принимает высокий уровень и остается таким
                                    // пока на фазе убывания счетчика снова не произодет событие compare match и сигнал не переключится на 0
  __DSB();                          // При отладке фиксировалось инверсная работа выхода компаратора A. Пытаемся защититься от этого оператором __DSB()
  R_GPTA0->GTIOR_b.OAE   = 1;       // Разрешаем выход компаратора A. Этот сигнал пойдет на модуль OPS
  __DSB();

  //---------------------------------------------------------------------
  // Блок программирования подачи сигнала на АЦП для организации синхронизированной с ШИМ выборкой
  //
  // Передаем новое значение в компаратор тригера АЦП на пике треугольника. Т.е. когда счетчик таймера достиг максимального значения
  R_GPTA0->GTBER_b.ADTTA = 1;          // GTADTRA Buffer Transfer Timing Select. 01: Transfer at crest.
  R_GPTA0->GTADTRA       = mod - 0x10; // Назначаем момент подачи сигнала триггера ADC. В данном случае тригеер сработает чуть раньше середины импульса ШИМ, чтобы АЦП корректно отработало выборку
  R_GPTA0->GTADTBRA      = mod - 0x10; // Назначаем момент подачи сигнала триггера ADC в буфферный регистр
  R_GPTA0->GTINTAD_b.ADTRAUEN = 1;     // Разрешаем выдачу сигнала триггера ADC только в фазе нарастания значений счетчика.
                                       // Чтобы не было двух сигналов от компаратора - при нарастании счетчика и при убывании счетчика
  __DSB();
  //---------------------------------------------------------------------

  R_GPTA0->GTCR_b.CST = 1; // Начинаем счет
  __DSB();

  return RES_OK;
}

/*-----------------------------------------------------------------------------------------------------


  \param val - нормированная к диапазону от -100 до +100 величина модуляции
-----------------------------------------------------------------------------------------------------*/
void GPT0_update_comare_reg(uint32_t val)
{
  uint32_t mod;
  uint32_t modulation = val;

  if (modulation > 100) modulation = 100;

  mod = R_GPTA0->GTPR + 1;
  val =(mod * (100 - modulation)) / 100;

  // Не даем прекратиться PWM и не даем импульсу стать слишком коротким
  if (val < MIN_PWM_COMPARE_VAL)
  {
    val = MIN_PWM_COMPARE_VAL;
  }
  else if ((mod - val) < MIN_PWM_COMPARE_VAL)
  {
    val = mod - MIN_PWM_COMPARE_VAL;
  }

  R_GPTA0->GTCCRC = val;          // Буфферизируем в регистр GTCCRC, и затем по окончании цикла это значение перенесется в регистр GTCCRA
}


